#!/usr/bin/env python3
"""Run ablation trials for places."""
from dataclasses import dataclass
from matplotlib.patches import Rectangle
import numpy as np
import multiprocessing as mp
import pandas as pd
import spark_dsg as dsg
from matplotlib.figure import Figure

import copy
import click
import functools
import dataclasses
import signal
import subprocess
import pickle
import shutil
import scipy.stats
import pathlib
import time
import tqdm
import yaml
import json
import re
import os

OBJECT_NAMES = {
    "office": "tasks_office_new_scaled",
    "apartment": "apartment_gt_grav_metric",
    "building33": "building33_tasks",
    "cubicle": "tasks_cubicle_scaled",
}

TASK_LIST = {
    "office": [
        "an image of a computing workspace",
        "an image of a hallway or corridor",
        "an image of a kitchenette",
        "an image of a conference room",
    ],
    "apartment": [
        "an image of a kitchen",
        "an image of a bedroom",
        "an image of a doorway",
    ],
    "building33": [
        "an image of a student lounge",
        "an image of a kitchenette or utility closet",
        "an image of a classroom",
        "an image of a conference room",
        "an image of a stairway",
        "an image of a workshop or machine shop",
        "an image of an aircraft hangar or garage",
    ],
}

SCENE_TASK_LIST = {
    "office": [
        "a workspace",
        "a hallway or corridor",
        "a kitchenette",
        "a conference room",
    ],
    "apartment": [
        "a kitchen",
        "a bedroom",
        "a dresser and mirror",
        "a desk and shelves",
    ],
    "cubicle": ["a desk and shelves", "floorspace with chairs"],
}


QUAL_TASKS = {
    "option_1": [
        "a workspace",
        "a hallway or corridor",
        "a conference room",
        "an entry way or landing",
        "a kitchenette",
    ],
    "option_2": [
        "desks and shelves",
        "a hallway or corridor",
        "a storage area",
        "a printer or copier",
        "a kitchenette",
        "blue and black backpacks and a table",
        "coats and a coat-rack",
    ],
}


@dataclass
class RunConfig:
    """Various global configuration options."""

    prerecorded: bool = True
    skip_existing: bool = False
    wait_time_s: float = 20.0
    bag_rate: float = 1.0
    shutdown_timeout_s: float = 60.0
    post_wait_time_s: float = 3.0
    node_name: str = "/hydra_llm_node"


@dataclasses.dataclass
class AblationInfo:
    """Quick struct to track run info."""

    trial: int
    scene_name: str
    clip_name: str
    ablation: str


def _get_info(path):
    trial, bag, ablation = path.parts[-3:]
    trial = int(trial[-3:])
    scene_name, clip_name = _split_bag_name(bag)
    return AblationInfo(
        trial=trial, scene_name=scene_name, clip_name=clip_name, ablation=ablation
    )


def _normalized_path(path_or_str):
    return pathlib.Path(path_or_str).expanduser().absolute()


def _get_llm_path():
    ret = subprocess.run(["rospack", "find", "llm"], capture_output=True, check=True)
    return _normalized_path(ret.stdout.decode("utf-8").strip())


def _get_llm_config_path():
    return _get_llm_path() / "experiments" / "configs" / "cluster"


def _get_ablation_paths(ablations):
    paths = []

    name_map = {
        "small": "rs_small_clip_averaging.yaml",
        "large": "rs_large_clip_averaging.yaml",
        "open": "rs_open_clip_averaging.yaml",
    }

    config_path = _get_llm_config_path()
    for ablation in ablations:
        if ablation not in name_map:
            click.secho(f"Unknown clip ablation '{ablation}'", fg="red")
            continue

        paths.append(config_path / name_map[ablation])

    return paths


def _underline(message, fill="=", add_newlines=True):
    underline = len(message) * fill
    # handles "fill" of length greater than 1
    total = message + "\n" + underline[: len(message)]
    if not add_newlines:
        return total

    return "\n" + total + "\n"


def build_args(config, is_hydra=True, selection_method=None, visualize=False):
    """Construct subprocess arguments."""
    args = [
        "roslaunch",
        "hydra_llm_ros",
        "realsense.launch",
        f"start_visualizer:={'false' if not visualize else 'true'}",
        "exit_after_clock:=true",
    ]
    args.append(f"geometric_places:={'true' if is_hydra else 'false'}")
    args.append(f"run_object_detector:={'false' if config.prerecorded else 'true'}")
    if not is_hydra:
        args.append(f"place_view_selection_type:={selection_method}")

    return args


def _format_tasks(prompts):
    return "[" + ", ".join([f'"{x}"' for x in prompts]) + "]"


def _get_tasks(bag_ablation, tasks):
    for scene, prompts in tasks.items():
        if scene in bag_ablation:
            return _format_tasks(prompts)

    click.secho(f"Could not find matching tasks for '{bag_ablation}'", fg="yellow")
    return "[]"


def _split_bag_name(bag_name):
    ret = re.search(r"_(rs_.*$)", bag_name)
    if ret is None:
        click.secho(f"Could not parse clip ablation from bag '{bag_name}'", fg="red")
        return bag_name, "rs_large_clip_averaging"

    return bag_name[: ret.start()], ret.group(1)


def run_pipeline(config, bag_path, path_out, name, args, dry_run, tasks=None):
    """Run hydra pipeline."""
    log_path = path_out / name
    if log_path.exists() and config.skip_existing:
        click.secho(f"\nSkiping existing '{name}' for '{bag_path.stem}'\n", fg="yellow")
        return

    if log_path.exists() and not dry_run:
        click.secho(f"Overwriting existing '{name}' at '{log_path}'", fg="yellow")
        shutil.rmtree(log_path)

    log_path.mkdir(parents=True, exist_ok=True)

    args = copy.deepcopy(args)
    args += [
        f"log_path:={log_path}",
        "glog_to_file:=true",
        "verbosity:=5",
        "min_glog_level:=0",
    ]

    click.secho(_underline(f"Running {name}", fill="-"), fg="green")

    _, conf_name = _split_bag_name(bag_path.stem)
    if conf_name is None:
        click.secho(f"Skipping {name} for {bag_path}!", fg="yellow")
        return

    conf_path = _get_llm_config_path() / f"{conf_name}.yaml"
    # mostly just sets the task server clip model
    args.append(f"object_detector_config:={conf_path}")

    if tasks is None:
        tasks = _get_tasks(bag_path.stem, TASK_LIST)

    object_tasks = None
    for scene, filename in OBJECT_NAMES.items():
        if scene in str(bag_path):
            object_tasks = filename
            break

    if object_tasks is not None:
        args.append(f"scene:={object_tasks}")

    args.append(f"places_task_prompts:={tasks}")

    if dry_run:
        click.secho(f"Skipping actual run of {name}", fg="yellow")
        click.secho(f"Command to run: {' '.join(args)}")
        return

    with (log_path / "clio_output.txt").open("w") as fout:
        try:
            proc = subprocess.Popen(args, stdout=fout, stderr=fout)
            time.sleep(config.wait_time_s)

            subprocess.run(
                ["rosbag", "play", "-r", str(config.bag_rate), str(bag_path), "--clock"]
            )
            try:
                click.secho(
                    f"Waiting for '{config.node_name}' to shutdown...", fg="green"
                )
                proc.wait(timeout=config.shutdown_timeout_s)
            except subprocess.TimeoutExpired:
                timeout_fmt = f"{config.shutdown_timeout_s} [s]"
                click.secho(
                    f"'{config.node_name}' did not finish after {timeout_fmt}!",
                    fg="red",
                )
                proc.send_signal(signal.SIGINT)
                click.secho("Waiting for '/hydra_llm_node' to exit...", fg="red")
                proc.wait()
        finally:
            proc.kill()

    click.secho(f"Finished running {name}", fg="green")
    time.sleep(config.post_wait_time_s)


def run_bag(
    config,
    trial_path,
    bag_path,
    dry_run,
    run_hydra=True,
    selection_methods=None,
    visualize=False,
):
    """Run ablations for a single bag."""
    bag_path = _normalized_path(bag_path)
    scene_name = bag_path.stem
    scene_path = trial_path / scene_name

    if selection_methods is None:
        selection_methods = ["boundary", "closest", "fusion"]

    if run_hydra:
        hydra_args = build_args(config, is_hydra=True, visualize=visualize)
        run_pipeline(config, bag_path, scene_path, "hydra", hydra_args, dry_run)

    for method in selection_methods:
        clio_args = build_args(
            config, is_hydra=False, selection_method=method, visualize=visualize
        )
        run_pipeline(config, bag_path, scene_path, f"clio_{method}", clio_args, dry_run)


@click.group()
def main():
    """Run or prepare place ablations."""
    pass


@main.command()
@click.argument("output_path")
@click.argument("bags", nargs=-1, type=click.Path(exists=True))
@click.option("--prerecorded/--no-prerecorded", default=True)
@click.option("--yes", "-y", is_flag=True, help="default to overwriting")
@click.option("--ablation", "-a", default="fusion", help="ablation to use")
@click.option("--visualize", "-v", is_flag=True, help="run visualizer")
@click.option(
    "--task-names",
    "-n",
    multiple=True,
    default=["option_1", "option_2"],
    help="names for tasks",
)
def run_qual(output_path, bags, prerecorded, yes, ablation, visualize, task_names):
    """
    Run single instance of clio with custom tasks.

    Usage:
        run_place_ablations OUTPUT_PATH BAG1 [BAG2...]

    Args:
        OUTPUT_PATH: directory to store results in
        BAGS: path to bags to run against
    """
    output_path = _normalized_path(output_path)
    if output_path.exists() and not yes:
        click.secho(f"Output at '{output_path}' already exists!", fg="red")
        click.confirm("Overwrite?", default=False, abort=True)

    output_path.mkdir(parents=True, exist_ok=True)

    config = RunConfig(prerecorded=prerecorded, skip_existing=False)

    for bag in bags:
        bag_path = _normalized_path(bag)
        scene_name = bag_path.stem
        scene_path = output_path / scene_name

        for task_name in task_names:
            qual_tasks = _format_tasks(QUAL_TASKS[task_name])
            args = build_args(
                config, is_hydra=False, selection_method=ablation, visualize=visualize
            )
            run_pipeline(
                config,
                bag_path,
                scene_path,
                f"clio_{task_name}",
                args,
                False,
                tasks=qual_tasks,
            )


@main.command()
@click.argument("output_path")
@click.argument("bags", nargs=-1, type=click.Path(exists=True))
@click.option("--prerecorded/--no-prerecorded", default=True)
@click.option("--yes", "-y", is_flag=True, help="default to overwriting")
@click.option("--visualize", "-v", is_flag=True, help="run visualizer")
def run_scenes(output_path, bags, prerecorded, yes, visualize):
    """
    Run single instance of clio with custom tasks.

    Usage:
        run_place_ablations OUTPUT_PATH BAG1 [BAG2...]

    Args:
        OUTPUT_PATH: directory to store results in
        BAGS: path to bags to run against
    """
    output_path = _normalized_path(output_path)
    if output_path.exists() and not yes:
        click.secho(f"Output at '{output_path}' already exists!", fg="red")
        click.confirm("Overwrite?", default=False, abort=True)

    output_path.mkdir(parents=True, exist_ok=True)

    config = RunConfig(prerecorded=prerecorded, skip_existing=False)

    for bag in bags:
        bag_path = _normalized_path(bag)
        scene_name = bag_path.stem

        tasks = _get_tasks(bag_path.stem, SCENE_TASK_LIST)
        args = build_args(
            config, is_hydra=False, selection_method="boundary", visualize=visualize
        )
        run_pipeline(
            config,
            bag_path,
            output_path,
            scene_name,
            args,
            False,
            tasks=tasks,
        )


@main.command()
@click.argument("output_path")
@click.argument("bags", nargs=-1, type=click.Path(exists=True))
@click.option("--prerecorded/--no-prerecorded", default=True)
@click.option("--num-trials", "-t", default=1, help="number of trials", type=int)
@click.option("--skip-existing", "-s", is_flag=True, help="skip existing folders")
@click.option("--dry-run", "-d", is_flag=True, help="skip actually running pipeline")
@click.option("--yes", "-y", is_flag=True, help="default to overwriting")
@click.option("--hydra/--no-hydra", default=True, help="run hydra ablation")
@click.option(
    "--ablations",
    "-a",
    multiple=True,
    default=["boundary", "closest", "fusion"],
    help="ablations to run",
)
@click.option("--visualize", "-v", is_flag=True, help="run visualizer")
def run(
    output_path,
    bags,
    prerecorded,
    num_trials,
    skip_existing,
    dry_run,
    yes,
    hydra,
    ablations,
    visualize,
):
    """
    Run ablations.

    Usage:
        run_place_ablations OUTPUT_PATH BAG1 [BAG2...]

    Args:
        OUTPUT_PATH: directory to store results in
        BAGS: path to bags to run against
    """
    output_path = _normalized_path(output_path)
    if output_path.exists() and not skip_existing and not yes:
        click.secho(f"Output at '{output_path}' already exists!", fg="red")
        click.confirm("Overwrite?", default=False, abort=True)

    output_path.mkdir(parents=True, exist_ok=True)

    config = RunConfig(prerecorded=prerecorded, skip_existing=skip_existing)

    for trial in range(1, num_trials + 1):
        trial_path = output_path / f"trial_{trial:03d}"
        trial_path.mkdir(parents=True, exist_ok=True)
        click.secho(_underline(f"Starting Trial {trial} of {num_trials}", fill="+-"))
        for bag in bags:
            run_bag(
                config,
                trial_path,
                bag,
                dry_run,
                run_hydra=hydra,
                selection_methods=ablations,
                visualize=visualize,
            )


@main.command()
@click.argument("output_path")
@click.argument("bags", nargs=-1, type=click.Path(exists=True))
@click.option("--skip-existing", "-s", is_flag=True, help="skip existing bags")
@click.option(
    "--ablations",
    "-a",
    type=str,
    multiple=True,
    default=["small", "large", "open"],
    help="specific model ablations to run",
)
@click.option(
    "--configs",
    "-c",
    type=click.Path(exists=True),
    multiple=True,
    default=[],
    help="config files not covered by ablations",
)
@click.option("--yes", "-y", is_flag=True, help="automatically overwrite")
def prep(output_path, bags, skip_existing, ablations, configs, yes):
    """
    Prepare ablation bags.

    Usage:
        run_place_ablations prep OUTPUT_PATH BAG1 [BAG2...]

    Args:
        OUTPUT_PATH: directory to store preprocessed bags in
        BAGS: path to bags to preprocess
    """
    output_path = _normalized_path(output_path)
    if output_path.exists() and not skip_existing and not yes:
        click.secho(f"Output at '{output_path}' already exists!", fg="red")
        click.confirm("Overwrite?", default=False, abort=True)

    output_path.mkdir(parents=True, exist_ok=True)

    base_args = [
        "/dominic/forward/color/image_raw:/dominic/forward/object_image",
        "--clip-vec",
        "--copy",
        "--yes",
    ]

    config_paths = [_normalized_path(x) for x in configs] + _get_ablation_paths(
        ablations
    )
    for idx, bag in enumerate(bags):
        click.secho(_underline(f"Processing Bag {idx + 1} of {len(bags)}", fill="+-"))
        args = ["rosrun", "llm", "make_rosbag"]
        bag_path = _normalized_path(bag)
        args += [str(bag_path)]
        args += base_args

        for config in config_paths:
            bag_output = output_path / f"{bag_path.stem}_{config.stem}.bag"
            if skip_existing and bag_output.exists():
                click.secho(f"Skipping existing '{bag_output}'", fg="yellow")
                continue

            banner = _underline(
                f"Starting config '{config}'", fill="-", add_newlines=False
            )
            click.secho(banner, fg="green")

            args += ["-o", str(bag_output)]
            args += ["-c", str(config)]

            subprocess.run(args)
            click.echo("")


# TODO(nathan) fix this at some point
SENSOR_CONFIG = """
type: camera
width: 640
height: 360
cx: 315.9902073557914
cy: 254.59437002701452
fx: 372.4634094238281
fy: 371.5072021484375
extrinsics:
  type: identity
"""


@main.command()
@click.argument("output_path", type=click.Path())
@click.argument("bag_paths", type=click.Path(exists=True), nargs=-1)
@click.option("--yes", "-y", is_flag=True, help="overwrite results")
@click.option("--skip-existing", "-s", is_flag=True, help="skip existing")
@click.option(
    "--voxel-size", "-v", default=0.1, type=float, help="voxel size for reconstruction"
)
@click.option("--min-range", default=0.3, type=float, help="min sensor range")
@click.option("--max-range", default=4.5, type=float, help="max sensor range")
@click.option("--min-log-level", default=0, type=int, help="glog min log level")
@click.option("--verbosity", default=0, type=int, help="glog verbosity")
def gt(
    output_path,
    bag_paths,
    yes,
    skip_existing,
    voxel_size,
    min_range,
    max_range,
    min_log_level,
    verbosity,
):
    """Construct GT reconstruction for bags."""
    output_path = _normalized_path(output_path)
    bag_paths = [_normalized_path(x) for x in bag_paths]

    for bag in bag_paths:
        scene_path = output_path / bag.stem
        if scene_path.exists() and skip_existing:
            click.secho(f"skipping existing '{scene_path}'", fg="green")
            continue

        if scene_path.exists() and not yes:
            click.secho(f"GT reconstruction exists at '{scene_path}'", fg="yellow")
            click.confirm("Overwrite?", default=False, abort=True)

        bag_config = {
            "bag_path": str(bag),
            "color_topic": "/dominic/forward/color/image_raw",
            "depth_topic": "/dominic/forward/depth/image_rect_raw",
            "sensor": yaml.safe_load(SENSOR_CONFIG),
            "world_frame": "world",
            "sensor_frame": "dominic/forward_link",
        }
        bag_config["sensor"]["min_range"] = min_range
        bag_config["sensor"]["max_range"] = max_range

        config = {
            "reconstructor": {"map": {"voxel_size": voxel_size}},
            "reader": {"bags": [bag_config]},
        }

        scene_path.mkdir(parents=True, exist_ok=True)
        config_path = scene_path / "settings.yaml"
        with config_path.open("w") as fout:
            fout.write(yaml.dump(config))
            fout.flush()
            os.fsync(fout)

        args = [
            "rosrun",
            "hydra_ros",
            "reconstruct_mesh",
            f"--output_path={scene_path}",
            f"--minloglevel={min_log_level}",
            f"-v={verbosity}",
            f"--config={config_path}",
        ]
        subprocess.call(args)


def _run_eval(args):
    path, gt_path, data_path, min_room_nodes = args
    info = _get_info(path)
    tsdf_path = gt_path / info.scene_name / "tsdf.vxblx"
    bbox_path = data_path / f"{info.scene_name}_rooms.yaml"
    dsg_path = path / "backend" / "dsg.json"

    proc_args = [
        "rosrun",
        "hydra",
        "evaluate_rooms",
        f"-tsdf_file={tsdf_path}",
        f"-bbox_file={bbox_path}",
        f"-dsg_file={dsg_path}",
        f"-min_room_nodes={min_room_nodes}",
        "-minloglevel=1",
    ]
    ret = subprocess.run(proc_args, capture_output=True)
    if len(ret.stdout) == 0:
        err_msg = ret.stderr.decode("utf-8").strip("\n")
        # from https://stackoverflow.com/questions/14693701
        ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
        err_msg = ansi_escape.sub("", err_msg)
        # strip glog prefix
        glog_escape = re.compile(r"[EW]\d{4}.*:\d+\] ")
        err_msg = glog_escape.sub("", err_msg)
        err_msg = err_msg.strip("\n")
        return path, None, err_msg

    results = ret.stdout.decode("utf-8").strip()
    results = json.loads(results)
    return path, results, None


@main.command()
@click.argument("result_path", type=click.Path(exists=True))
@click.argument("gt_path", type=click.Path(exists=True))
@click.option("--min-room-nodes", "-m", type=int, default=0, help="min room nodes")
@click.option("--threads", "-t", type=int, default=8)
def eval(result_path, gt_path, min_room_nodes, threads):
    """Compute results."""
    result_path = _normalized_path(result_path)
    gt_path = _normalized_path(gt_path)
    data_path = _get_llm_path() / "dataconfigs"

    all_paths = []
    trials = [x for x in result_path.iterdir() if x.is_dir()]
    for trial in trials:
        scenes = [x for x in trial.iterdir() if x.is_dir()]
        for scene in scenes:
            all_paths += [x for x in scene.iterdir() if x.is_dir()]

    all_paths = sorted(all_paths)
    all_args = [(x, gt_path, data_path, min_room_nodes) for x in all_paths]

    all_results = {}
    mp.set_start_method("forkserver")
    with mp.Pool(threads) as p:
        bar = tqdm.tqdm(p.imap_unordered(_run_eval, all_args), total=len(all_args))
        for path, result, err_msg in bar:
            if result is None:
                rel_path = path.relative_to(result_path)
                click.secho(f"'{rel_path}' failed: '{err_msg}'", fg="red")
                continue

            all_results[path] = result

    with (result_path / "metrics.pickle").open("wb") as fout:
        pickle.dump(all_results, fout)


@main.command()
@click.argument("result_path", type=click.Path(exists=True))
def check(result_path):
    """Compute results."""
    result_path = _normalized_path(result_path)

    all_paths = []
    trials = [x for x in result_path.iterdir() if x.is_dir()]
    for trial in trials:
        scenes = [x for x in trial.iterdir() if x.is_dir()]
        for scene in scenes:
            all_paths += [x for x in scene.iterdir() if x.is_dir()]

    all_paths = sorted(all_paths)
    for path in all_paths:
        message = ""

        log_path = path / "clio_output.txt"
        if not log_path.exists():
            message = "Missing output log!"

        with log_path.open("r") as fin:
            contents = fin.read()
            if "new node registered" in contents:
                message = "Improper shutdown!"

        if message == "":
            click.secho(f"{path}: good!", fg="green")
        else:
            click.secho(f"{path}: fail! (reason: {message})", fg="red")


def _convert_results_to_df(results, filters=None, use_total=False):
    columns = {}
    columns["scene"] = []
    columns["clip"] = []
    columns["ablation"] = []
    columns["precision"] = []
    columns["recall"] = []
    columns["f1"] = []
    columns["trial"] = []

    for path, data in results.items():
        info = _get_info(path)
        if filters is not None and sum([x(info) for x in filters]):
            click.secho(f"skipping {info}", fg="yellow")
            continue

        columns["scene"].append(info.scene_name)
        columns["clip"].append(info.clip_name)
        columns["ablation"].append(info.ablation)
        columns["trial"].append(info.trial)

        if use_total:
            precision = data["total_precision"]
            recall = data["total_recall"]
        else:
            precision = np.mean(data["precisions"])
            recall = np.mean(data["recalls"])

        columns["precision"].append(precision)
        columns["recall"].append(recall)
        columns["f1"].append(scipy.stats.hmean([precision, recall]))

    return pd.DataFrame(columns)


def _format(
    mean, std, prec=3, latex=False, bold=False, underline=False, include_std=True
):
    def _get_num(num):
        return f"{{:0.{prec}f}}".format(num)

    use_std = include_std and not np.isnan(std)
    mean_str = _get_num(mean)
    if not latex:
        ret = mean_str if not use_std else f"{mean_str} ± {_get_num(std)}"
        return ret

    if use_std:
        latex_str = rf"{mean_str} $\pm$ {_get_num(std)}"
    else:
        latex_str = mean_str

    if bold:
        return rf"\textbf{{{latex_str}}}"
    elif underline:
        return rf"\underline{{{latex_str}}}"
    else:
        return latex_str


def _get_scene_table(df):
    ablations = sorted(df["ablation"].unique())
    # column ordering: precision, recall, f1
    means = np.zeros((len(ablations), 3))
    stds = np.zeros((len(ablations), 3))
    order = ["precision", "recall", "f1"]
    for idx, ablation in enumerate(ablations):
        metrics = df[df["ablation"] == ablation]
        metrics = metrics[order]
        mean = metrics.mean()
        std = metrics.std()
        means[idx, :] = np.array([mean[x] for x in order])
        stds[idx, :] = np.array([std[x] for x in order])

    return ablations, means, stds


def _get_ablation_values(df, ablation):
    ablation_df = df[df["ablation"] == ablation]
    # column ordering: precision, recall, f1
    values = np.zeros((len(ablation_df), 3))
    order = ["precision", "recall", "f1"]
    for row_values in ablation_df.itertuples(index=False):
        for col, metric in enumerate(order):
            values[row_values.trial - 1, col] = getattr(row_values, metric)

    return values


@main.command()
@click.argument("result_path", type=click.Path(exists=True))
@click.option(
    "--clip-models", default=["rs_large_clip_averaging"], help="models to show"
)
@click.option("--use-total", "-t", is_flag=True, help="use total precision and recall")
def show(result_path, clip_models, use_total):
    """Show results in table form."""
    result_path = _normalized_path(result_path)
    pickle_path = result_path / "metrics.pickle"
    if not pickle_path.exists():
        click.secho("Missing metrics! Must run eval before this!", fg="red")
        return

    with (result_path / "metrics.pickle").open("rb") as fin:
        results = pickle.load(fin)

    def model_filter(info):
        if len(clip_models) == 0:
            return False

        return info.clip_name not in clip_models

    df = _convert_results_to_df(results, filters=[model_filter], use_total=use_total)
    for clip_model in df["clip"].unique():
        print(_underline(clip_model))

    for scene in df["scene"].unique():
        print(_underline(scene, "-", add_newlines=False))
        scene_df = df[(df["scene"] == scene) & (df["clip"] == clip_model)]
        ablations, means, stds = _get_scene_table(scene_df)

        max_len = max([len(x) for x in ablations])
        for idx, ablation in enumerate(ablations):
            row = [_format(means[idx, c], stds[idx, c]) for c in range(3)]
            name = f"{{: >{max_len + 1}}}".format(ablation)
            print(f"  - {name}: precision={row[0]}, recall={row[1]}, f1={row[2]}")

            trial_results = _get_ablation_values(scene_df, ablation)
            for idx in range(trial_results.shape[0]):
                row = [_format(trial_results[idx, c], np.nan) for c in range(3)]
                trial_name = f"{{: >{max_len + 11}}}".format(f"  - trial {idx + 1}")
                print(f"{trial_name}: p={row[0]}, r={row[1]}, f1={row[2]}")

        print("")


NAME_MAP = {
    "hydra": "Hydra",
    "clio_boundary": "Clio (boundary)",
    "clio_closest": "Clio (closest)",
    "clio_fusion": "Clio (average)",
}

SCENE_MAP = {
    "apartment_grav_processed": "Apartment",
    "office_test_processed": "Office",
    "building33_processed": "Building",
}

TABLE_HEADER = r"""\begin{table}[t!]
    \scriptsize
    \centering
    \begin{tabularx}{\columnwidth}{lXccc}
        Dataset & Method & Precision$\uparrow$ & Recall$\uparrow$ & F1$\uparrow$ \\
        \midrule
"""

TABLE_FOOTER = r"""        \bottomrule
    \end{tabularx}
    \caption{Comparison of Geometric Room Segmentation Accuracy}\label{table:places}
\end{table}
"""


def _get_multirow_column(scene, N):
    return rf"\multirow{{{N}}}{{*}}{{{SCENE_MAP.get(scene, scene)}}}"


def _get_rankings(values, tolerance=1.0e-3):
    ordering = np.argsort(values, axis=0)[::-1, :]
    ranks = np.zeros_like(ordering)
    for col in range(ranks.shape[1]):
        curr_rank = 1
        ranks[ordering[0, col], col] = curr_rank
        for row in range(1, values.shape[0]):
            v_curr = values[ordering[row, col], col]
            v_prev = values[ordering[row - 1, col], col]
            change = np.abs(v_curr - v_prev) > tolerance
            curr_rank += change
            ranks[ordering[row, col], col] = curr_rank

    return ranks


@main.command()
@click.argument("result_path", type=click.Path(exists=True))
@click.option(
    "-m", "--model", default="rs_large_clip_averaging", help="clip model to use"
)
@click.option("-u", "--underline", is_flag=True, help="underline second best method")
@click.option("-p", "--precision", default=2, help="floating point precision to use")
@click.option("-o", "--output", default=None, help="file to save to")
def table(result_path, model, underline, precision, output):
    """Show results in table form."""
    result_path = _normalized_path(result_path)
    pickle_path = result_path / "metrics.pickle"
    if not pickle_path.exists():
        click.secho("Missing metrics! Must run eval before this!", fg="red")
        return

    with (result_path / "metrics.pickle").open("rb") as fin:
        results = pickle.load(fin)

    df = _convert_results_to_df(results)
    df = df[df["clip"] == model]
    N_ablations = len(df["ablation"].unique())
    scene_column_map = {
        x: _get_multirow_column(x, N_ablations) for x in df["scene"].unique()
    }
    max_scene_length = max([len(x) for _, x in scene_column_map.items()])

    if output is None:
        output = pathlib.Path("table.tex")
    else:
        output = _normalized_path(output)

    with output.open("w") as fout:
        fout.write(TABLE_HEADER)
        for idx, scene in enumerate(df["scene"].unique()):
            if idx != 0:
                fout.write(" " * 8 + r"\midrule" + "\n")

            scene_df = df[(df["scene"] == scene)]
            ablations, means, stds = _get_scene_table(scene_df)
            rankings = _get_rankings(means)

            ablations = [NAME_MAP.get(x, x) for x in ablations]
            max_len = max([len(x) for x in ablations])

            for idx, ablation in enumerate(ablations):
                name = f"{{: >{max_len + 1}}}".format(ablation)

                metrics = []
                for i in range(3):
                    should_bold = rankings[idx, i] == 1
                    should_underline = rankings[idx, i] == 2 and underline
                    raw_str = _format(
                        means[idx, i],
                        stds[idx, i],
                        prec=precision,
                        latex=True,
                        bold=should_bold,
                        underline=should_underline,
                    )
                    metrics.append(f"{raw_str: >30}")

                scene_to_use = " " if idx != 0 else scene_column_map[scene]
                scol = f"{{: <{max_scene_length}}}".format(scene_to_use)
                row = f"{scol} & {name} & " + " & ".join(metrics)
                fout.write(" " * 8 + row + r" \\" + "\n")

        fout.write(TABLE_FOOTER)


def _line_length(x):
    return len(x) + sum([len(w) for w in x])


def _wrap(label, width=15):
    words = label.split(" ")
    lines = []

    line = []
    for word in words:
        if len(line) == 0:
            line.append(word)
            continue

        curr_length = len(word) + _line_length(line)
        if curr_length > width:
            lines.append(" ".join(line))
            line = [word]
        else:
            line.append(word)

    if len(line) > 0:
        lines.append(" ".join(line))

    return "\n".join(lines)


# adapted from https://matplotlib.org/stable/gallery/color/named_colors.html
def _make_grid_legend(
    color_dict,
    nrows=4,
    ncols=None,
    cell_width=60,
    cell_height=22,
    dpi=300,
    fontsize=8,
    wrapsize=14,
    offset=1,
    alpha=1.0,
    sort=False,
):
    """Plot a color table."""
    N = len(color_dict)
    if ncols is None or nrows * ncols < N:
        ncols = N // nrows + int(N % nrows > 0)

    width = cell_width * ncols
    height = cell_height * nrows
    figsize = (width / dpi, height / dpi)

    fig = Figure(dpi=dpi, figsize=figsize)
    ax = fig.subplots()
    ax.set_axis_off()

    fig.subplots_adjust(0.0, 0.0, 1.0, 1.0)
    ax.set_xlim(0, cell_width * ncols)
    ax.set_ylim(cell_height * (nrows - 0.5), -cell_height / 2.0)

    labels = sorted([x for x in color_dict]) if sort else [x for x in color_dict]
    for i, label in enumerate(labels):
        col = i % ncols
        row = i // ncols
        y = row * cell_height

        start_x = cell_width * col

        prod = (1 / alpha) * functools.reduce(
            lambda x, y: x * y, color_dict[label][:3], 1
        )
        print(color_dict[label], prod)
        if prod > 0.1:
            textcolor = (0.3, 0.3, 0.3)
            # textcolor = (0.0, 0.0, 0.0)
        else:
            textcolor = (1.0, 1.0, 1.0)
            # textcolor = (0.0, 0.0, 0.0)

        ax.text(
            start_x + offset,
            y,
            _wrap(label, width=wrapsize),
            fontsize=fontsize,
            horizontalalignment="left",
            verticalalignment="center",
            color=textcolor,
        )

        ax.add_patch(
            Rectangle(
                xy=(start_x, y - cell_height / 2),
                width=cell_width,
                height=cell_height,
                facecolor=color_dict[label],
                alpha=alpha,
            )
        )

    return fig


@main.command()
@click.argument("task_name")
@click.option("--qual/--no-qual", default=True)
@click.option("-r", "--num-rows", type=int, default=2)
@click.option("--num-cols", type=int, default=None)
@click.option("-d", "--dpi", type=float, default=600.0)
@click.option("-o", "--output", default=None)
@click.option("-a", "--alpha", type=float, default=0.6)
@click.option("-w", "--cell-width", type=float, default=1900)
@click.option("-h", "--cell-height", type=float, default=850)
@click.option("-f", "--fontsize", type=int, default=28)
@click.option("-t", "--wrap", type=int, default=14)
@click.option("--offset", type=float, default=50)
def make_color_legend(
    task_name,
    qual,
    num_rows,
    num_cols,
    dpi,
    output,
    alpha,
    cell_width,
    cell_height,
    fontsize,
    offset,
    wrap,
):
    """Plot labels and colors."""
    colors = np.array(
        [
            [166, 206, 227],
            [31, 120, 180],
            [178, 223, 138],
            [51, 160, 44],
            [251, 154, 153],
            [227, 26, 28],
            [253, 191, 111],
            [255, 127, 0],
            [202, 178, 214],
            [106, 61, 154],
            [255, 255, 153],
            [177, 89, 40],
        ]
    ).astype(np.float64)
    colors /= 255.0

    if qual:
        tasks = QUAL_TASKS[task_name]
    else:
        tasks = SCENE_TASK_LIST[task_name]

    color_dict = {x: colors[i] for i, x in enumerate(tasks)}
    color_dict["null task"] = (0.0, 0.0, 0.0)

    fig = _make_grid_legend(
        color_dict,
        nrows=num_rows,
        ncols=num_cols,
        dpi=dpi,
        alpha=alpha,
        cell_width=cell_width,
        cell_height=cell_height,
        fontsize=fontsize,
        offset=offset,
        wrapsize=wrap,
    )
    if output is None:
        output = f"{task_name}.png"

    fig.savefig(output, dpi=dpi)


SCENE_PATH_NAME_MAP = {
    "office": "office_test_processed_rs_large_clip_averaging",
    "apartment": "apartment_grav_processed_rs_large_clip_averaging",
    "building33": "building33_processed_rs_large_clip_averaging",
}


@main.command()
@click.argument("result_path", type=click.Path(exists=True))
@click.argument("scene")
@click.argument("ablation")
@click.argument("trial", type=int)
def visualize(result_path, scene, ablation, trial):
    """Show scene graph."""
    result_path = _normalized_path(result_path)
    scene_name = SCENE_PATH_NAME_MAP[scene]
    dsg_path = (
        result_path
        / f"trial_{trial:03d}"
        / scene_name
        / ablation
        / "backend"
        / "dsg_with_mesh.json"
    )

    args = [
        "roslaunch",
        "hydra_llm_ros",
        "hydra_llm_visualizer.launch",
        f"scene_graph_path:={dsg_path}",
        "viz_config_file:=region_visualizer_config.yaml",
    ]
    subprocess.run(args)


@main.command()
@click.argument("dsg_path", type=click.Path(exists=True))
@click.option("--default/--no-default", default=False, help="use default visualizer")
@click.option("--rviz-file", "-r", default="llm_static_visualizer.yaml")
def visualize_path(dsg_path, default, rviz_file):
    """Show scene graph."""
    dsg_path = _normalized_path(dsg_path)
    args = [
        "roslaunch",
        "hydra_llm_ros",
        "hydra_llm_visualizer.launch",
        f"scene_graph_path:={dsg_path}",
    ]

    object_tasks = None
    for scene, filename in OBJECT_NAMES.items():
        if scene in str(dsg_path):
            object_tasks = filename
            break

    if object_tasks is not None:
        args.append(f"scene:={object_tasks}")

    if not default:
        args.append("viz_config_file:=region_visualizer_config.yaml")
        args.append("rviz_file:=region_visualizer.rviz")
    else:
        args.append(f"rviz_file:={rviz_file}")

    subprocess.run(args)


@main.command()
@click.argument("dsg_path", type=click.Path(exists=True))
def remap_labels(dsg_path):
    """Remap labels."""
    dsg_path = str(_normalized_path(dsg_path))
    scene = None
    if "office" in dsg_path:
        scene = "office"
    elif "cubicle" in dsg_path:
        scene = "cubicle"
    elif "apartment" in dsg_path:
        scene = "apartment"

    tasks = SCENE_TASK_LIST[scene]

    G = dsg.DynamicSceneGraph.load(dsg_path)
    regions = G.get_layer(dsg.DsgLayers.ROOMS)
    for node in regions.nodes:
        if node.attributes.name == "":
            continue

        task_idx = tasks.index(node.attributes.name)
        node.attributes.name = f"({task_idx + 1})"

    G.save(dsg_path, include_mesh=True)


if __name__ == "__main__":
    main()
